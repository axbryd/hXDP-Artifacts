
xdp_tx_iptunnel_kern.o:	file format ELF64-BPF

Disassembly of section xdp_tx_iptunnel:
_xdp_tx_iptunnel:
; {
       0:	bf 16 00 00 00 00 00 00 	r6 = r1
       1:	b7 08 00 00 01 00 00 00 	r8 = 1
; void *data_end = (void *)(long)xdp->data_end;
       2:	61 62 04 00 00 00 00 00 	r2 = *(u32 *)(r6 + 4)
; void *data = (void *)(long)xdp->data;
       3:	61 61 00 00 00 00 00 00 	r1 = *(u32 *)(r6 + 0)
; if (eth + 1 > data_end)
       4:	bf 13 00 00 00 00 00 00 	r3 = r1
       5:	07 03 00 00 0e 00 00 00 	r3 += 14
       6:	2d 23 12 01 00 00 00 00 	if r3 > r2 goto +274 <LBB0_32>
; h_proto = eth->h_proto;
       7:	71 14 0c 00 00 00 00 00 	r4 = *(u8 *)(r1 + 12)
       8:	71 13 0d 00 00 00 00 00 	r3 = *(u8 *)(r1 + 13)
       9:	67 03 00 00 08 00 00 00 	r3 <<= 8
      10:	4f 43 00 00 00 00 00 00 	r3 |= r4
; if (h_proto == htons(ETH_P_IP))
      11:	15 03 12 00 86 dd 00 00 	if r3 == 56710 goto +18 <LBB0_17>
      12:	b7 08 00 00 02 00 00 00 	r8 = 2
      13:	55 03 0b 01 08 00 00 00 	if r3 != 8 goto +267 <LBB0_32>
; struct vip vip = {};
      14:	b7 03 00 00 00 00 00 00 	r3 = 0
      15:	7b 3a f0 ff 00 00 00 00 	*(u64 *)(r10 - 16) = r3
      16:	7b 3a e8 ff 00 00 00 00 	*(u64 *)(r10 - 24) = r3
      17:	7b 3a e0 ff 00 00 00 00 	*(u64 *)(r10 - 32) = r3
; if (iph + 1 > data_end)
      18:	bf 14 00 00 00 00 00 00 	r4 = r1
      19:	07 04 00 00 22 00 00 00 	r4 += 34
      20:	b7 08 00 00 01 00 00 00 	r8 = 1
      21:	2d 24 03 01 00 00 00 00 	if r4 > r2 goto +259 <LBB0_32>
; dport = get_dport(iph + 1, data_end, iph->protocol);
      22:	71 14 17 00 00 00 00 00 	r4 = *(u8 *)(r1 + 23)
; switch (protocol) {
      23:	15 04 16 00 11 00 00 00 	if r4 == 17 goto +22 <LBB0_7>
      24:	55 04 1a 00 06 00 00 00 	if r4 != 6 goto +26 <LBB0_9>
; if (th + 1 > data_end)
      25:	bf 13 00 00 00 00 00 00 	r3 = r1
      26:	07 03 00 00 36 00 00 00 	r3 += 54
      27:	b7 08 00 00 01 00 00 00 	r8 = 1
      28:	2d 23 fc 00 00 00 00 00 	if r3 > r2 goto +252 <LBB0_32>
      29:	05 00 14 00 00 00 00 00 	goto +20 <LBB0_8>

LBB0_17:
; struct vip vip = {};
      30:	b7 03 00 00 00 00 00 00 	r3 = 0
      31:	7b 3a f0 ff 00 00 00 00 	*(u64 *)(r10 - 16) = r3
      32:	7b 3a e8 ff 00 00 00 00 	*(u64 *)(r10 - 24) = r3
      33:	7b 3a e0 ff 00 00 00 00 	*(u64 *)(r10 - 32) = r3
; if (ip6h + 1 > data_end)
      34:	bf 14 00 00 00 00 00 00 	r4 = r1
      35:	07 04 00 00 36 00 00 00 	r4 += 54
      36:	b7 08 00 00 01 00 00 00 	r8 = 1
      37:	2d 24 f3 00 00 00 00 00 	if r4 > r2 goto +243 <LBB0_32>
; dport = get_dport(ip6h + 1, data_end, ip6h->nexthdr);
      38:	71 14 14 00 00 00 00 00 	r4 = *(u8 *)(r1 + 20)
; switch (protocol) {
      39:	15 04 7a 00 11 00 00 00 	if r4 == 17 goto +122 <LBB0_21>
      40:	55 04 7e 00 06 00 00 00 	if r4 != 6 goto +126 <LBB0_23>
; if (th + 1 > data_end)
      41:	bf 13 00 00 00 00 00 00 	r3 = r1
      42:	07 03 00 00 4a 00 00 00 	r3 += 74
      43:	b7 08 00 00 01 00 00 00 	r8 = 1
      44:	2d 23 ec 00 00 00 00 00 	if r3 > r2 goto +236 <LBB0_32>
      45:	05 00 78 00 00 00 00 00 	goto +120 <LBB0_22>

LBB0_7:
; if (uh + 1 > data_end)
      46:	bf 13 00 00 00 00 00 00 	r3 = r1
      47:	07 03 00 00 2a 00 00 00 	r3 += 42
      48:	b7 08 00 00 01 00 00 00 	r8 = 1
      49:	2d 23 e7 00 00 00 00 00 	if r3 > r2 goto +231 <LBB0_32>

LBB0_8:
      50:	69 13 24 00 00 00 00 00 	r3 = *(u16 *)(r1 + 36)

LBB0_9:
; vip.protocol = iph->protocol;
      51:	73 4a f4 ff 00 00 00 00 	*(u8 *)(r10 - 12) = r4
      52:	b7 08 00 00 02 00 00 00 	r8 = 2
; vip.family = AF_INET;
      53:	6b 8a f2 ff 00 00 00 00 	*(u16 *)(r10 - 14) = r8
; vip.daddr.v4 = iph->daddr;
      54:	61 12 1e 00 00 00 00 00 	r2 = *(u32 *)(r1 + 30)
; vip.dport = dport;
      55:	6b 3a f0 ff 00 00 00 00 	*(u16 *)(r10 - 16) = r3
; vip.daddr.v4 = iph->daddr;
      56:	63 2a e0 ff 00 00 00 00 	*(u32 *)(r10 - 32) = r2
; payload_len = ntohs(iph->tot_len);
      57:	69 19 10 00 00 00 00 00 	r9 = *(u16 *)(r1 + 16)
      58:	bf a2 00 00 00 00 00 00 	r2 = r10
; vip.protocol = iph->protocol;
      59:	07 02 00 00 e0 ff ff ff 	r2 += -32
; tnl = bpf_map_lookup_elem(&vip2tnl, &vip);
      60:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
      62:	85 00 00 00 01 00 00 00 	call 1
      63:	bf 07 00 00 00 00 00 00 	r7 = r0
; if (!tnl || tnl->family != AF_INET)
      64:	15 07 d8 00 00 00 00 00 	if r7 == 0 goto +216 <LBB0_32>
      65:	69 71 20 00 00 00 00 00 	r1 = *(u16 *)(r7 + 32)
      66:	55 01 d6 00 02 00 00 00 	if r1 != 2 goto +214 <LBB0_32>
; if (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct iphdr)))
      67:	bf 61 00 00 00 00 00 00 	r1 = r6
      68:	18 02 00 00 ec ff ff ff 00 00 00 00 00 00 00 00 	r2 = 4294967276 ll
      70:	85 00 00 00 2c 00 00 00 	call 44
      71:	67 00 00 00 20 00 00 00 	r0 <<= 32
      72:	77 00 00 00 20 00 00 00 	r0 >>= 32
      73:	b7 08 00 00 01 00 00 00 	r8 = 1
      74:	55 00 ce 00 00 00 00 00 	if r0 != 0 goto +206 <LBB0_32>
; data = (void *)(long)xdp->data;
      75:	61 61 00 00 00 00 00 00 	r1 = *(u32 *)(r6 + 0)
; data_end = (void *)(long)xdp->data_end;
      76:	61 62 04 00 00 00 00 00 	r2 = *(u32 *)(r6 + 4)
; if (new_eth + 1 > data_end ||
      77:	bf 13 00 00 00 00 00 00 	r3 = r1
      78:	07 03 00 00 0e 00 00 00 	r3 += 14
      79:	b7 08 00 00 01 00 00 00 	r8 = 1
      80:	2d 23 c8 00 00 00 00 00 	if r3 > r2 goto +200 <LBB0_32>
; old_eth + 1 > data_end ||
      81:	bf 13 00 00 00 00 00 00 	r3 = r1
      82:	07 03 00 00 22 00 00 00 	r3 += 34
      83:	b7 08 00 00 01 00 00 00 	r8 = 1
      84:	2d 23 c4 00 00 00 00 00 	if r3 > r2 goto +196 <LBB0_32>
      85:	b7 08 00 00 01 00 00 00 	r8 = 1
; if (new_eth + 1 > data_end ||
      86:	2d 23 c2 00 00 00 00 00 	if r3 > r2 goto +194 <LBB0_32>
      87:	dc 09 00 00 10 00 00 00 	r9 = be16 r9
      88:	bf 12 00 00 00 00 00 00 	r2 = r1
      89:	07 02 00 00 14 00 00 00 	r2 += 20
; memcpy(new_eth->h_source, old_eth->h_dest, sizeof(new_eth->h_source));
      90:	71 23 05 00 00 00 00 00 	r3 = *(u8 *)(r2 + 5)
      91:	73 31 0b 00 00 00 00 00 	*(u8 *)(r1 + 11) = r3
      92:	71 23 04 00 00 00 00 00 	r3 = *(u8 *)(r2 + 4)
      93:	73 31 0a 00 00 00 00 00 	*(u8 *)(r1 + 10) = r3
      94:	71 23 03 00 00 00 00 00 	r3 = *(u8 *)(r2 + 3)
      95:	73 31 09 00 00 00 00 00 	*(u8 *)(r1 + 9) = r3
      96:	71 23 02 00 00 00 00 00 	r3 = *(u8 *)(r2 + 2)
      97:	73 31 08 00 00 00 00 00 	*(u8 *)(r1 + 8) = r3
      98:	71 23 01 00 00 00 00 00 	r3 = *(u8 *)(r2 + 1)
      99:	73 31 07 00 00 00 00 00 	*(u8 *)(r1 + 7) = r3
     100:	71 22 00 00 00 00 00 00 	r2 = *(u8 *)(r2 + 0)
     101:	73 21 06 00 00 00 00 00 	*(u8 *)(r1 + 6) = r2
; memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));
     102:	71 72 22 00 00 00 00 00 	r2 = *(u8 *)(r7 + 34)
     103:	71 73 23 00 00 00 00 00 	r3 = *(u8 *)(r7 + 35)
     104:	71 74 24 00 00 00 00 00 	r4 = *(u8 *)(r7 + 36)
     105:	71 75 25 00 00 00 00 00 	r5 = *(u8 *)(r7 + 37)
     106:	71 70 26 00 00 00 00 00 	r0 = *(u8 *)(r7 + 38)
     107:	71 76 27 00 00 00 00 00 	r6 = *(u8 *)(r7 + 39)
     108:	b7 08 00 00 04 00 00 00 	r8 = 4
; iph->protocol = IPPROTO_IPIP;
     109:	73 81 17 00 00 00 00 00 	*(u8 *)(r1 + 23) = r8
; memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));
     110:	73 61 05 00 00 00 00 00 	*(u8 *)(r1 + 5) = r6
     111:	73 01 04 00 00 00 00 00 	*(u8 *)(r1 + 4) = r0
     112:	b7 00 00 00 00 00 00 00 	r0 = 0
; iph->frag_off =	0;
     113:	6b 01 14 00 00 00 00 00 	*(u16 *)(r1 + 20) = r0
; iph->check = 0;
     114:	6b 01 18 00 00 00 00 00 	*(u16 *)(r1 + 24) = r0
; new_eth->h_proto = h_proto;
     115:	73 01 0d 00 00 00 00 00 	*(u8 *)(r1 + 13) = r0
; memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));
     116:	73 51 03 00 00 00 00 00 	*(u8 *)(r1 + 3) = r5
     117:	73 41 02 00 00 00 00 00 	*(u8 *)(r1 + 2) = r4
     118:	73 31 01 00 00 00 00 00 	*(u8 *)(r1 + 1) = r3
     119:	73 21 00 00 00 00 00 00 	*(u8 *)(r1 + 0) = r2
; iph->ihl = sizeof(*iph) >> 2;
     120:	b7 02 00 00 45 00 00 00 	r2 = 69
     121:	6b 21 0e 00 00 00 00 00 	*(u16 *)(r1 + 14) = r2
; iph->tot_len = htons(payload_len + sizeof(*iph));
     122:	07 09 00 00 14 00 00 00 	r9 += 20
     123:	dc 09 00 00 10 00 00 00 	r9 = be16 r9
     124:	6b 91 10 00 00 00 00 00 	*(u16 *)(r1 + 16) = r9
     125:	b7 03 00 00 08 00 00 00 	r3 = 8
; new_eth->h_proto = h_proto;
     126:	73 31 0c 00 00 00 00 00 	*(u8 *)(r1 + 12) = r3
; iph->daddr = tnl->daddr.v4;
     127:	61 72 10 00 00 00 00 00 	r2 = *(u32 *)(r7 + 16)
     128:	63 21 1e 00 00 00 00 00 	*(u32 *)(r1 + 30) = r2
; iph->saddr = tnl->saddr.v4;
     129:	61 74 00 00 00 00 00 00 	r4 = *(u32 *)(r7 + 0)
; iph->ttl = 8;
     130:	73 31 16 00 00 00 00 00 	*(u8 *)(r1 + 22) = r3
; iph->saddr = tnl->saddr.v4;
     131:	63 41 1a 00 00 00 00 00 	*(u32 *)(r1 + 26) = r4
; csum += *next_iph_u16++;
     132:	69 13 0e 00 00 00 00 00 	r3 = *(u16 *)(r1 + 14)
     133:	0f 93 00 00 00 00 00 00 	r3 += r9
     134:	69 15 12 00 00 00 00 00 	r5 = *(u16 *)(r1 + 18)
     135:	0f 53 00 00 00 00 00 00 	r3 += r5
     136:	69 15 16 00 00 00 00 00 	r5 = *(u16 *)(r1 + 22)
     137:	0f 53 00 00 00 00 00 00 	r3 += r5
     138:	bf 45 00 00 00 00 00 00 	r5 = r4
     139:	57 05 00 00 ff ff 00 00 	r5 &= 65535
     140:	0f 53 00 00 00 00 00 00 	r3 += r5
     141:	77 04 00 00 10 00 00 00 	r4 >>= 16
     142:	0f 43 00 00 00 00 00 00 	r3 += r4
     143:	bf 24 00 00 00 00 00 00 	r4 = r2
     144:	57 04 00 00 ff ff 00 00 	r4 &= 65535
     145:	0f 43 00 00 00 00 00 00 	r3 += r4
     146:	77 02 00 00 10 00 00 00 	r2 >>= 16
     147:	0f 23 00 00 00 00 00 00 	r3 += r2
; iph->check = ~((csum & 0xffff) + (csum >> 16));
     148:	bf 32 00 00 00 00 00 00 	r2 = r3
     149:	77 02 00 00 10 00 00 00 	r2 >>= 16
     150:	0f 32 00 00 00 00 00 00 	r2 += r3
     151:	a7 02 00 00 ff ff ff ff 	r2 ^= -1
     152:	6b 21 18 00 00 00 00 00 	*(u16 *)(r1 + 24) = r2
; count_tx(vip.protocol);
     153:	71 a1 f4 ff 00 00 00 00 	r1 = *(u8 *)(r10 - 12)
     154:	63 1a fc ff 00 00 00 00 	*(u32 *)(r10 - 4) = r1
     155:	bf a2 00 00 00 00 00 00 	r2 = r10
; __be16 h_proto)
     156:	07 02 00 00 fc ff ff ff 	r2 += -4
; rxcnt_count = bpf_map_lookup_elem(&rxcnt, &protocol);
     157:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
     159:	85 00 00 00 01 00 00 00 	call 1
; if (rxcnt_count)
     160:	15 00 77 00 00 00 00 00 	if r0 == 0 goto +119 <LBB0_31>
     161:	05 00 73 00 00 00 00 00 	goto +115 <LBB0_30>

LBB0_21:
; if (uh + 1 > data_end)
     162:	bf 13 00 00 00 00 00 00 	r3 = r1
     163:	07 03 00 00 3e 00 00 00 	r3 += 62
     164:	b7 08 00 00 01 00 00 00 	r8 = 1
     165:	2d 23 73 00 00 00 00 00 	if r3 > r2 goto +115 <LBB0_32>

LBB0_22:
     166:	69 13 38 00 00 00 00 00 	r3 = *(u16 *)(r1 + 56)

LBB0_23:
; vip.family = AF_INET6;
     167:	b7 02 00 00 0a 00 00 00 	r2 = 10
     168:	6b 2a f2 ff 00 00 00 00 	*(u16 *)(r10 - 14) = r2
; vip.protocol = ip6h->nexthdr;
     169:	73 4a f4 ff 00 00 00 00 	*(u8 *)(r10 - 12) = r4
; memcpy(vip.daddr.v6, ip6h->daddr.s6_addr32, sizeof(vip.daddr));
     170:	61 12 26 00 00 00 00 00 	r2 = *(u32 *)(r1 + 38)
     171:	61 14 2a 00 00 00 00 00 	r4 = *(u32 *)(r1 + 42)
     172:	61 15 2e 00 00 00 00 00 	r5 = *(u32 *)(r1 + 46)
     173:	61 10 32 00 00 00 00 00 	r0 = *(u32 *)(r1 + 50)
; vip.dport = dport;
     174:	6b 3a f0 ff 00 00 00 00 	*(u16 *)(r10 - 16) = r3
; memcpy(vip.daddr.v6, ip6h->daddr.s6_addr32, sizeof(vip.daddr));
     175:	67 00 00 00 20 00 00 00 	r0 <<= 32
     176:	4f 50 00 00 00 00 00 00 	r0 |= r5
     177:	7b 0a e8 ff 00 00 00 00 	*(u64 *)(r10 - 24) = r0
     178:	67 04 00 00 20 00 00 00 	r4 <<= 32
     179:	4f 24 00 00 00 00 00 00 	r4 |= r2
     180:	7b 4a e0 ff 00 00 00 00 	*(u64 *)(r10 - 32) = r4
; payload_len = ip6h->payload_len;
     181:	69 19 12 00 00 00 00 00 	r9 = *(u16 *)(r1 + 18)
     182:	bf a2 00 00 00 00 00 00 	r2 = r10
; vip.family = AF_INET6;
     183:	07 02 00 00 e0 ff ff ff 	r2 += -32
; tnl = bpf_map_lookup_elem(&vip2tnl, &vip);
     184:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
     186:	85 00 00 00 01 00 00 00 	call 1
     187:	bf 07 00 00 00 00 00 00 	r7 = r0
     188:	b7 08 00 00 02 00 00 00 	r8 = 2
; if (!tnl || tnl->family != AF_INET6)
     189:	15 07 5b 00 00 00 00 00 	if r7 == 0 goto +91 <LBB0_32>
     190:	69 71 20 00 00 00 00 00 	r1 = *(u16 *)(r7 + 32)
     191:	55 01 59 00 0a 00 00 00 	if r1 != 10 goto +89 <LBB0_32>
; if (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct ipv6hdr)))
     192:	bf 61 00 00 00 00 00 00 	r1 = r6
     193:	18 02 00 00 d8 ff ff ff 00 00 00 00 00 00 00 00 	r2 = 4294967256 ll
     195:	85 00 00 00 2c 00 00 00 	call 44
     196:	67 00 00 00 20 00 00 00 	r0 <<= 32
     197:	77 00 00 00 20 00 00 00 	r0 >>= 32
     198:	b7 08 00 00 01 00 00 00 	r8 = 1
     199:	55 00 51 00 00 00 00 00 	if r0 != 0 goto +81 <LBB0_32>
; data = (void *)(long)xdp->data;
     200:	61 61 00 00 00 00 00 00 	r1 = *(u32 *)(r6 + 0)
; data_end = (void *)(long)xdp->data_end;
     201:	61 62 04 00 00 00 00 00 	r2 = *(u32 *)(r6 + 4)
; if (new_eth + 1 > data_end ||
     202:	bf 13 00 00 00 00 00 00 	r3 = r1
     203:	07 03 00 00 0e 00 00 00 	r3 += 14
     204:	b7 08 00 00 01 00 00 00 	r8 = 1
     205:	2d 23 4b 00 00 00 00 00 	if r3 > r2 goto +75 <LBB0_32>
; old_eth + 1 > data_end ||
     206:	bf 13 00 00 00 00 00 00 	r3 = r1
     207:	07 03 00 00 36 00 00 00 	r3 += 54
     208:	b7 08 00 00 01 00 00 00 	r8 = 1
     209:	2d 23 47 00 00 00 00 00 	if r3 > r2 goto +71 <LBB0_32>
     210:	b7 08 00 00 01 00 00 00 	r8 = 1
; if (new_eth + 1 > data_end ||
     211:	2d 23 45 00 00 00 00 00 	if r3 > r2 goto +69 <LBB0_32>
     212:	bf 12 00 00 00 00 00 00 	r2 = r1
     213:	07 02 00 00 28 00 00 00 	r2 += 40
; memcpy(new_eth->h_source, old_eth->h_dest, sizeof(new_eth->h_source));
     214:	71 23 05 00 00 00 00 00 	r3 = *(u8 *)(r2 + 5)
     215:	73 31 0b 00 00 00 00 00 	*(u8 *)(r1 + 11) = r3
     216:	71 23 04 00 00 00 00 00 	r3 = *(u8 *)(r2 + 4)
     217:	73 31 0a 00 00 00 00 00 	*(u8 *)(r1 + 10) = r3
     218:	71 23 03 00 00 00 00 00 	r3 = *(u8 *)(r2 + 3)
     219:	73 31 09 00 00 00 00 00 	*(u8 *)(r1 + 9) = r3
     220:	71 23 02 00 00 00 00 00 	r3 = *(u8 *)(r2 + 2)
     221:	73 31 08 00 00 00 00 00 	*(u8 *)(r1 + 8) = r3
     222:	71 23 01 00 00 00 00 00 	r3 = *(u8 *)(r2 + 1)
     223:	73 31 07 00 00 00 00 00 	*(u8 *)(r1 + 7) = r3
     224:	71 22 00 00 00 00 00 00 	r2 = *(u8 *)(r2 + 0)
     225:	73 21 06 00 00 00 00 00 	*(u8 *)(r1 + 6) = r2
; memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));
     226:	71 72 22 00 00 00 00 00 	r2 = *(u8 *)(r7 + 34)
     227:	71 73 23 00 00 00 00 00 	r3 = *(u8 *)(r7 + 35)
     228:	71 74 24 00 00 00 00 00 	r4 = *(u8 *)(r7 + 36)
     229:	71 75 25 00 00 00 00 00 	r5 = *(u8 *)(r7 + 37)
     230:	71 70 26 00 00 00 00 00 	r0 = *(u8 *)(r7 + 38)
     231:	71 76 27 00 00 00 00 00 	r6 = *(u8 *)(r7 + 39)
; ip6h->priority = 0;
     232:	b7 08 00 00 60 00 00 00 	r8 = 96
     233:	6b 81 0e 00 00 00 00 00 	*(u16 *)(r1 + 14) = r8
; new_eth->h_proto = h_proto;
     234:	b7 08 00 00 dd 00 00 00 	r8 = 221
     235:	73 81 0d 00 00 00 00 00 	*(u8 *)(r1 + 13) = r8
     236:	b7 08 00 00 86 00 00 00 	r8 = 134
     237:	73 81 0c 00 00 00 00 00 	*(u8 *)(r1 + 12) = r8
; memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));
     238:	73 61 05 00 00 00 00 00 	*(u8 *)(r1 + 5) = r6
     239:	73 01 04 00 00 00 00 00 	*(u8 *)(r1 + 4) = r0
     240:	b7 00 00 00 00 00 00 00 	r0 = 0
; memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
     241:	73 01 10 00 00 00 00 00 	*(u8 *)(r1 + 16) = r0
     242:	73 01 11 00 00 00 00 00 	*(u8 *)(r1 + 17) = r0
     243:	dc 09 00 00 10 00 00 00 	r9 = be16 r9
; ip6h->payload_len = htons(ntohs(payload_len) + sizeof(*ip6h));
     244:	07 09 00 00 28 00 00 00 	r9 += 40
     245:	dc 09 00 00 10 00 00 00 	r9 = be16 r9
     246:	6b 91 12 00 00 00 00 00 	*(u16 *)(r1 + 18) = r9
; ip6h->nexthdr = IPPROTO_IPV6;
     247:	b7 00 00 00 29 08 00 00 	r0 = 2089
     248:	6b 01 14 00 00 00 00 00 	*(u16 *)(r1 + 20) = r0
; memcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));
     249:	73 51 03 00 00 00 00 00 	*(u8 *)(r1 + 3) = r5
     250:	73 41 02 00 00 00 00 00 	*(u8 *)(r1 + 2) = r4
     251:	73 31 01 00 00 00 00 00 	*(u8 *)(r1 + 1) = r3
     252:	73 21 00 00 00 00 00 00 	*(u8 *)(r1 + 0) = r2
; memcpy(ip6h->saddr.s6_addr32, tnl->saddr.v6, sizeof(tnl->saddr.v6));
     253:	61 72 0c 00 00 00 00 00 	r2 = *(u32 *)(r7 + 12)
     254:	63 21 22 00 00 00 00 00 	*(u32 *)(r1 + 34) = r2
     255:	61 72 08 00 00 00 00 00 	r2 = *(u32 *)(r7 + 8)
     256:	63 21 1e 00 00 00 00 00 	*(u32 *)(r1 + 30) = r2
     257:	61 72 04 00 00 00 00 00 	r2 = *(u32 *)(r7 + 4)
     258:	63 21 1a 00 00 00 00 00 	*(u32 *)(r1 + 26) = r2
     259:	61 72 00 00 00 00 00 00 	r2 = *(u32 *)(r7 + 0)
     260:	63 21 16 00 00 00 00 00 	*(u32 *)(r1 + 22) = r2
; memcpy(ip6h->daddr.s6_addr32, tnl->daddr.v6, sizeof(tnl->daddr.v6));
     261:	61 72 1c 00 00 00 00 00 	r2 = *(u32 *)(r7 + 28)
     262:	63 21 32 00 00 00 00 00 	*(u32 *)(r1 + 50) = r2
     263:	61 72 18 00 00 00 00 00 	r2 = *(u32 *)(r7 + 24)
     264:	63 21 2e 00 00 00 00 00 	*(u32 *)(r1 + 46) = r2
     265:	61 72 14 00 00 00 00 00 	r2 = *(u32 *)(r7 + 20)
     266:	63 21 2a 00 00 00 00 00 	*(u32 *)(r1 + 42) = r2
     267:	61 72 10 00 00 00 00 00 	r2 = *(u32 *)(r7 + 16)
     268:	63 21 26 00 00 00 00 00 	*(u32 *)(r1 + 38) = r2
; count_tx(vip.protocol);
     269:	71 a1 f4 ff 00 00 00 00 	r1 = *(u8 *)(r10 - 12)
     270:	63 1a fc ff 00 00 00 00 	*(u32 *)(r10 - 4) = r1
     271:	bf a2 00 00 00 00 00 00 	r2 = r10
; __be16 h_proto)
     272:	07 02 00 00 fc ff ff ff 	r2 += -4
; rxcnt_count = bpf_map_lookup_elem(&rxcnt, &protocol);
     273:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
     275:	85 00 00 00 01 00 00 00 	call 1
; if (rxcnt_count)
     276:	15 00 03 00 00 00 00 00 	if r0 == 0 goto +3 <LBB0_31>

LBB0_30:
; *rxcnt_count += 1;
     277:	79 01 00 00 00 00 00 00 	r1 = *(u64 *)(r0 + 0)
     278:	07 01 00 00 01 00 00 00 	r1 += 1
     279:	7b 10 00 00 00 00 00 00 	*(u64 *)(r0 + 0) = r1

LBB0_31:
     280:	b7 08 00 00 03 00 00 00 	r8 = 3

LBB0_32:
; }
     281:	bf 80 00 00 00 00 00 00 	r0 = r8
     282:	95 00 00 00 00 00 00 00 	exit
